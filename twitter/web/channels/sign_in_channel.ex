defmodule Twitter.SignInChannel do
    use Twitter.Web, :channel
    alias Twitter.Subscription
    alias Twitter.Tweet
    alias Twitter.UserService
    alias Twitter.User


    def join("sign_in:" <> account, _params, socket) do
        IO.puts("+++++++++++++")
        IO.puts(account)
        IO.puts("+++++++++++++")

        {:ok, map} = Ecto.Adapters.SQL.query(Twitter.Repo, "SELECT publickeys
        FROM user_table
        WHERE account = $1", [account])

        [[publicKey]] = map.rows
        IO.puts(publicKey)

        {a, b, c} = :erlang.timestamp()
        current_time = to_string(a) <> to_string(b) <> to_string(c)

        IO.puts("********current time generated by server is: ")
        IO.puts(current_time)

        encrypted = RSA.encrypt(current_time, {:public, RSA.decode_key(publicKey)})
        IO.puts("********server encrypt the current time using public key: ")
        IO.inspect(encrypted)
        {:ok, Base.encode64(encrypted), assign(socket, :account, {account, current_time, publicKey})}
    end

    def handle_in("challenge:" <> message, _params, socket) do
        {_, answer, _} = socket.assigns.account
        case message == answer do
            true -> {:reply, {:ok, %{message: "authenticate successful"}}, socket}
            false -> {:reply, {:error, %{message: "authenticate unsuccessful"}}, socket}
        end
    end

    def handle_in("subscribe:" <> subscribee, _params, socket) do
        {account, _, _} = socket.assigns.account
        UserService.subscribe(account, subscribee)

#        changeset = Subscription.changeset(%Subscription{}, %{subscriber: account, subscribee: subscribee})
#
#        case Repo.insert(changeset) do
#            {:ok, post} -> IO.inspect(post)
#            {:error, changeset} -> IO.inspect(changeset)
#        end
#
#        IO.puts("------------------")
#        IO.puts("subscribe successful")
#        IO.puts("------------------")


        {:reply, {:ok, %{subscribee: subscribee}}, socket}
    end

    def handle_in("unsubscribe:" <> subscribee, _params, socket) do

        {account, _, _} = socket.assigns.account
        UserService.unsubscribe(account, subscribee)

#        Ecto.Adapters.SQL.query(Twitter.Repo, "DELETE FROM subscription
#        WHERE subscriber = $1
#        AND subscribee = $2", [account, subscribee])
#
#        IO.puts("------------------")
#        IO.puts("unsubscribe successful")
#        IO.puts("------------------")

        {:reply, {:ok, %{subscribee: subscribee}}, socket}

    end

    def handle_in("subscribee_tweet:", _params, socket) do
        {account, _, _} = socket.assigns.account
        tweet = UserService.subscribee_tweet(account)

#        {:ok, map} = Ecto.Adapters.SQL.query(Twitter.Repo, "SELECT tweet_content
#        FROM tweet
#        WHERE tweet.publisher = $1
#        OR tweet.publisher
#        IN (SELECT subscribee FROM subscription WHERE subscriber = $1)", [account])
#
#        tweet = map.rows
#        IO.inspect(tweet)
#
#        IO.puts("------------------")
#        IO.puts("show subscribees' tweet successful")
#        IO.puts("------------------")

        {:reply, {:ok, %{tweet: tweet}}, socket}
    end

    def handle_in("pound_tweet:", _params, socket) do
        {account, _, _} = socket.assigns.account
        tweet = UserService.pound_tweet(account)

#        {:ok, map} = Ecto.Adapters.SQL.query(Twitter.Repo, "SELECT tweet_content
#        FROM tweet
#        WHERE tweet.pound_account = $1", [account])
#
#        tweet = map.rows
#        IO.inspect(tweet)
#
#        IO.puts("------------------")
#        IO.puts("show pound_account's tweet successful")
#        IO.puts("------------------")

        {:reply, {:ok, %{tweet: tweet}}, socket}
    end

    def handle_in("at_tweet:", _params, socket) do
        {account, _, _} = socket.assigns.account
        tweet = UserService.at_tweet(account)

#        {:ok, map} = Ecto.Adapters.SQL.query(Twitter.Repo, "SELECT tweet_content
#        FROM tweet
#        WHERE tweet.at_account = $1", [account])
#
#        tweet = map.rows
#        IO.inspect(tweet)
#
#        IO.puts("------------------")
#        IO.puts("show at_account's tweet successful")
#        IO.puts("------------------")

        {:reply, {:ok, %{tweet: tweet}}, socket}
    end


    def handle_in("new_tweet:", params, socket) do
        {account, _, publicKey} = socket.assigns.account
#        {:ok, content} = Base.decode64(content)
#        content = RSA.decrypt(content, {:public, RSA.decode_key(publicKey)})
#        IO.puts("this is the content: " <> content)

        secret = RS256.generate_secret_key(account)
        params = RS256.decode(params, secret)

        IO.inspect(params)
#        UserService.new_tweet(account, content, params)
        tweet = UserService.new_tweet(account, params.content, params.suffix)

#        case params do
#            %{"pound_account" => pound_account, "at_account" => at_account} -> new_tweet_helper(account, content, pound_account, at_account)
#            %{"pound_account" => pound_account} -> new_tweet_helper(account, content, pound_account, nil)
#            %{"at_account" => at_account} -> new_tweet_helper(account, content, nil, at_account)
#            %{} -> new_tweet_helper(account, content, nil, nil)
#
#        end
#
#        IO.puts("------------------")
#        IO.puts("publish new tweet successful")
#        IO.puts("------------------")

        {:reply, {:ok, %{tweet: tweet}}, socket}
    end

    def handle_in("retweet:" <> tweet_id, params, socket) do
        {account, _, _} = socket.assigns.account
        tweet = UserService.retweet(account, tweet_id, params)

        #        get content by id
#        {:ok, map} = Ecto.Adapters.SQL.query(Twitter.Repo, "SELECT tweet_content
#        FROM tweet
#        where id = $1", [String.to_integer(tweet_id)])
#
#        [[content]] = map.rows
#
#        case params do
#            %{"pound_account" => pound_account, "at_account" => at_account} -> new_tweet_helper(account, content, pound_account, at_account)
#            %{"pound_account" => pound_account} -> new_tweet_helper(account, content, pound_account, nil)
#            %{"at_account" => at_account} -> new_tweet_helper(account, content, nil, at_account)
#            %{} -> new_tweet_helper(account, content, nil, nil)
#
#        end
#
#        IO.puts("------------------")
#        IO.puts("retweet successful")
#        IO.puts("------------------")

        {:reply, {:ok, %{tweet: tweet}}, socket}
    end

#    defp new_tweet_helper(account, content, pound_account, at_account) do
#        IO.puts(pound_account)
#        IO.puts(at_account)
#
#        changeset = Tweet.changeset(%Tweet{}, %{"tweet_content" => content,
#            "publisher" => account, "pound_account" => pound_account, "at_account" => at_account})
#
#        case Repo.insert(changeset) do
#            {:ok, post} -> IO.inspect(post)
#            {:error, changeset} -> IO.inspect(changeset)
#        end
#    end
end